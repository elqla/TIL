[TOC]

# 1

## 배열

```solidity
// 2개의 원소를 담을 수 있는 고정 길이의 배열:
uint[2] fixedArray;
// 또다른 고정 배열으로 5개의 스트링을 담을 수 있다:
string[5] stringArray;
// 동적 배열은 고정된 크기가 없으며 계속 크기가 커질 수 있다:
uint[] dynamicArray;
Person[] people; // 이는 동적 배열로, 원소를 계속 추가할 수 있다.Person[] people; // 이는 동적 배열로, 원소를 계속 추가할 수 있다.
```

### Public

`public`으로 배열을 선언할 수 있지. 솔리디티는 이런 배열을 위해 ***getter\*** 메소드를 자동적으로 생성하지. 구문은 다음과 같네:

```
Person[] public people;
```

그러면 다른 컨트랙트들이 이 배열을 읽을 수 있게 되지 (쓸 수는 없네). 이는 컨트랙트에 공개 데이터를 저장할 때 유용한 패턴이지.

```solidity
pragma solidity ^0.4.19;

contract ZombieFactory {

    uint dnaDigits = 16;
    uint dnaModulus = 10 ** dnaDigits;

    struct Zombie {
        string name;
        uint dna;
    }
    // Zombie 구조체의 public 배열을 생성하고 이름을 zombies로 한다
    Zombie[] public zombies;

    function createZombie(string _name, uint _dna) {
        // 여기서 시작
    }
}
```

# 2. web3

### Web3 프로바이더(Provider)

이더리움은 똑같은 데이터의 복사본을 공유하는 **_노드_**들로 구성되어 있네. Web3.js에서 Web3 프로바이더를 설정하는 것은 우리 코드에 읽기와 쓰기를 처리하려면 **어떤 노드**와 통신을 해야 하는지 설정하는 것이지. 이는 전통적인 웹 앱에서 API 호출을 위해 원격 웹 서버의 URL을 설정하는 것과 같네.

자네는 자네만의 이더리움 노드를 프로바이더로 운영할 수도 있네. 하지만 자네가 편리하게 쓸 수 있는 제3자 서비스가 있네. 자네 DApp의 사용자들을 위해 자네만의 이더리움 노드를 운영할 필요가 없도록 하기 위해 사용할 수 있는 서비스 말이네 - ***Infura\***라는 게 있지.

## Infura

[Infura](https://infura.io/)는 빠른 읽기를 위한 캐시 계층을 포함하는 다수의 이더리움 노드를 운영하는 서비스이네. 접근을 위한 API를 무료로 사용할 수 있지. Infura를 프로바이더로 사용하면, 자네만의 이더리움을 설치하고 계속 유지할 필요 없이 이더리움 블록체인과 메세지를 확실히 주고받을 수 있네.

다음과 같이 Web3에 자네의 Web3 프로바이더로 Infura를 쓰도록 설정할 수 있네:

```
var web3 = new Web3(new Web3.providers.WebsocketProvider("wss://mainnet.infura.io/ws"));
```

하지만, 많은 사용자들이 우리의 DApp을 사용할 것이기에 - 그리고 이 사용자들은 단순히 읽기만 하는 게 아니라 블록체인에 뭔가 쓰기도 할 것이기에 - 우리는 이 사용자들이 그들의 개인 키로 트랜잭션에 서명을 할 수 있도록 해야 할 것이네.

> 참고: 이더리움(그리고 일반적으로 블록체인)은 트랜잭션에 전자 서명을 하기 위해 공개/개인 키 쌍을 사용하네. 말하자면 전자 서명을 위해 엄청나게 안전한 비밀번호 같은 것이지. 이런 방식으로 내가 만약 블록체인에서 어떤 데이터를 변경하면, 나의 공개 키를 통해 내가 거기 서명을 한 사람이라고 **증명**할 수 있네 - 하지만 아무도 내 개인 키를 모르기 때문에, 내 트랜잭션을 누구도 위조할 수 없지.

이런 암호학은 복잡하네. 그러니 자네가 보안 전문가이고 진짜로 무엇을 하고 있는지 알지 못한다면, 우리의 앱 프론트엔드에서 사용자들의 개인 키를 관리하려 하는 것은 아마 좋은 생각이 아닐 것이네.

하지만 운이 좋게도 자네는 그렇게 할 필요가 없네 - 이를 대신 처리해주는 서비스가 이미 있네. 이중 가장 유명한 것은 ***메타마스크(Metamask)\***이네.

## 메타마스크(Metamask)

[메타마스크](https://metamask.io/)는 사용자들이 이더리움 계정과 개인 키를 안전하게 관리할 수 있게 해주는 크롬과 파이어폭스의 브라우저 확장 프로그램이네. 그리고 해당 계정들을 써서 Web3.js를 사용하는 웹사이트들과 상호작용을 할 수 있도록 해주지(만약 자네가 이걸 써본 적이 없다면, 자네는 분명 이걸 설치해보고 싶을 것이네 - 그러면 자네의 브라우저에서 Web3가 작동하고, 이더리움 블록체인과 통신하는 어떤 웹사이트와도 상호작용을 할 수 있지!).

그리고 개발자로서, 사용자들이 웹 브라우저를 써서 웹사이트를 통해 자네의 DApp과 상호작용을 하길 원한다면(우리의 크립토좀비 게임에서 하듯이), 자네는 분명 자네 DApp을 메타마스크와 호환할 수 있게 하고 싶을 것이네.

> **참고**: 메타마스크는 내부적으로 Infura의 서버를 Web3 프로바이더로 사용하네. 위에서 우리가 했던 것처럼 말이야 - 하지만 사용자들에게 그들만의 Web3 프로바이더를 선택할 수 있는 옵션을 주기도 하지. 즉 메타마스크의 Web3 프로바이더를 사용하면, 사용자에게 선택권을 주는 것이기도 하면서 자네 앱에서 걱정할 거리를 하나 줄일 수 있지.

## 메타마스크의 Web3 프로바이더 사용하기

메타마스크는 `web3`라는 전역 자바스크립트 객체를 통해 브라우저에 Web3 프로바이더를 주입하네. 그러니 자네 앱에서는 `web3`가 존재하는지 확인하고, 만약 존재한다면 `web3.currentProvider`를 프로바이더로서 사용하면 되지.

여기 메타마스크에서 제공하는 템플릿 코드가 있네. 사용자가 메타마스크를 설치했는지 확인하고 설치가 안 된 경우 우리 앱을 사용하려면 메타마스크를 설치해야 한다고 알려주는 것이지:

```
window.addEventListener('load', function() {

  // Web3가 브라우저에 주입되었는지 확인(Mist/MetaMask)
  if (typeof web3 !== 'undefined') {
    // Mist/MetaMask의 프로바이더 사용
    web3js = new Web3(web3.currentProvider);
  } else {
    // 사용자가 Metamask를 설치하지 않은 경우에 대해 처리
    // 사용자들에게 Metamask를 설치하라는 등의 메세지를 보여줄 것
  }

  // 이제 자네 앱을 시작하고 web3에 자유롭게 접근할 수 있네:
  startApp()

})
```

자네는 자네가 만드는 모든 앱에서 이 예제 코드를 사용할 수 있네. 사용자들이 자네 앱을 사용하려면 메타마스크를 사용하도록 하기 위해서 말이네.

> 참고: 메타마스크 말고도 사용자들이 쓸 수 있는 다른 개인 키 관리 프로그램도 있네. **미스트(Mist)** 웹 브라우저 같은 것들이지. 하지만, 그것들도 모두 `web3` 변수를 주입하는 동일한 형태를 사용하네. 그러니 사용자들이 다른 프로그램을 쓰더라도 여기서 우리가 설명하는 방식으로 사용자의 Web3 프로바이더를 인식할 수 있을 것이네.

## 직접 해보기

HTML 파일에서 `</body>` 태그를 써서 닫기 전에 빈 script 태그를 만들어 놓았네. 여기에 이번 레슨을 위한 자바스크립트 코드를 쓸 수 있는 것이지.

1. 위에서 말한 메타마스크를 인식하기 위한 템플릿 코드를 코드를 복사/붙여넣기 하게. `window.addEventListener`로 시작하는 블록이네.

---

---







Web3.js는 컨트랙트의 함수를 호출하기 위해 우리가 사용할 두 개의 메소드를 가지고 있네: `call`과 `send`이지.

### Call

`call`은 `view`와 `pure` 함수를 위해 사용하네. 로컬 노드에서만 실행하고, 블록체인에 트랜잭션을 만들지 않지.

> **복습:** `view`와 `pure` 함수는 읽기 전용이고 블록체인에서 상태를 변경하지 않네. 가스를 전혀 소모하지 않고, 메타마스크에서 트랜잭션에 서명하라고 사용자에게 창을 띄우지도 않지.

Web3.js를 사용하여, 다음과 같이 `123`을 매개 변수로 `myMethod`라는 이름의 함수를 `call`할 수 있네:

```
myContract.methods.myMethod(123).call()
```

### Send

`send`는 트랜잭션을 만들고 블록체인 상의 데이터를 변경하네. `view`와 `pure`가 아닌 모든 함수에 대해 `send`를 사용해야 하는 것이지.

> **참고:** 트랜잭션을 `send`하는 것은 사용자에게 가스를 지불하도록 하고, 메타마스크에서 트랜잭션에 서명하라고 창을 띄울 것이네. Web3 프로바이더로 메타마스크를 사용할 때, `send()`를 호출하면 자동으로 이 모든 것이 이루어지고, 우리의 코드에 어떤 특별한 것도 추가할 필요가 없지. 꽤나 훌륭하지!?

Web3.js를 사용하여, 다음과 같이 `123`을 매개 변수로 `myMethod`라는 이름의 함수를 호출하는 트랜잭션을 `send`할 수 있네:

```
myContract.methods.myMethod(123).send()
```

구문은 `call()`과 거의 똑같지.

## 좀비 데이터 받기

이제 컨트랙트에서 데이터에 접근하기 위해 `call`을 사용하는 실제 예제를 살펴보겠네.

우리가 좀비 배열을 `public`으로 만들었던 것을 기억해보게:

```
Zombie[] public zombies;
```

솔리디티에서, `public`으로 변수를 선언하면 자동으로 같은 이름의 퍼블릭 "getter" 함수를 만들어 내네. 그러니 자네가 ID `15`인 좀비를 찾길 원한다면, 변수를 함수인 것처럼 호출할 수 있지: `zombies(15)`.

여기에 우리의 프론트엔드에서 좀비 ID를 받아 해당 좀비에 대해 컨트랙트에 질의를 보내고, 결과를 반환하는 자바스크립트 함수를 작성하는 방법이 있네:

> 참고: 이번 레슨에서 우리가 사용하는 모든 코드 예제들은 콜백 대신 Promise를 사용하는 Web3.js **1.0 버전**을 사용하고 있네. 자네가 온라인에서 찾을 수 있는 다른 많은 튜토리얼들에서는 Web3.js의 이전 버전을 사용하고 있네. 1.0 버전에서 문법이 많이 바뀌었으니, 만약 자네가 다른 튜토리얼에서 코드를 복사해온다면 같은 버전을 사용하고 있는지 확인해보게!

```
function getZombieDetails(id) {
  return cryptoZombies.methods.zombies(id).call()
}

// 함수를 호출하고 결과를 가지고 무언가를 처리:
getZombieDetails(15)
.then(function(result) {
  console.log("Zombie 15: " + JSON.stringify(result));
});
```

여기서 일어나고 있는 것들을 알아보도록 하지.

`cryptoZombies.methods.zombies(id).call()`는 Web3 프로바이더와 통신하여 우리 컨트랙트의 `Zombie[] public zombies`에서 인덱스가 `id`인 좀비를 반환하도록 할 것이네.

이는 외부 서버로 API 호출을 하는 것처럼 **비동기**적으로 일어난다는 것을 알아두게. 즉 Web3는 여기서 Promise를 반환하네(만약 자네가 자바스크립트 Promise에 익숙하지 않다면... 계속하기 전에 추가적인 숙제를 해야 할 때이군!).

Promise가 만들어지면(이는 Web3 프로바이더로부터 응답을 받았다는 것을 의미하지) 우리 예제 코드는 `then` 문장을 실행하고, 여기서 `result`를 콘솔에 로그로 기록하지.

`result`는 다음과 같이 생긴 자바스크립트 객체가 될 것이네:

```
{
  "name": "H4XF13LD MORRIS'S COOLER OLDER BROTHER",
  "dna": "1337133713371337",
  "level": "9999",
  "readyTime": "1522498671",
  "winCount": "999999999",
  "lossCount": "0" // Obviously.
}
```

이후 이 객체를 해석하기 위한 프론트엔드 로직을 만들어 의미 있는 방향으로 이 객체를 프론트엔드에 표시할 것이네.

## 직접 해보기

자네를 위해 내가 먼저 `getZombieDetails`를 코드에 복사해 놓았네.

1. `zombieToOwner`와 비슷한 함수를 만들도록 하지. `ZombieFactory.sol`을 기억한다면, 다음과 같이 생긴 매핑이 생각날 것이네:

   ```
   mapping (uint => address) public zombieToOwner;
   ```

   `zombieToOwner`라는 이름으로 자바스크립트 함수를 정의하게. 위의 `getZombieDetails`와 비슷하게, 이 함수는 `id`를 매개 변수로 받고 우리 컨트랙트의 `zombieToOwner`에 대한 Web3.js `call`을 반환할 것이네.

2. 그 아래에, 세 번째 함수로 `getZombiesByOwner`를 만들게. `ZombieHelper.sol`이 기억난다면, 다음과 같이 생긴 함수가 생각날 것이네:

   ```
   function getZombiesByOwner(address _owner)
   ```

   우리의 `getZombiesByOwner` 함수는 `owner`를 매개 변수로 받고, `getZombiesByOwner`에 대한 Web3.js `call`을 반환할 것이네.