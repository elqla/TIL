### 비트 연산자

- & 비트 단위로 and 연산을 한다.
  - if문에서 i&(1<<j): i의 j번째 비트가 1인지 아닌지 검사한다.
    - 숫자 > 0   ;True    -1         
    - 숫자 < 0   ; False  -0        
- | 비트 단위로 or 연산을 한다.
- << 피연산자의 비트 열을 왼쪽으로 이동시킨다.  (*10)
  - 1<< n:2n 즉, 원소가 n개의 경우의 모든 부분집합의 수를 의미
- \>> 피연산자의 비트 열을 오른쪽으로 이동시킨다. (//10) 
  - ex)   5번째 비트가 1인 값   =>          a = 1  <<  <u>5</u>

`부분집합구하기`  =  2**n (공집합 포함)

```python
arr = [3, 6, 7, 1, 5, 4]
n = len(arr) #원소갯수

for i in range(1<<n):   #부분집합의 갯수
    for j in range(n):  #원소의 수만큼 비트를 비교
        if i&(i<<j):    #i의 j번 비트가 1인경우
            print(arr[j], end=", ")   #j번 원소 출력
    print()
print()
```



```python
n = 4  #원소 갯수
lst = [3, 6, 7, 1, 5, 4]
power_set = []
for i in range(1 << n):  # 2**4 = 16, 0~15까지의 수를 확인
    tmp_set = []  # i마다 하나의 부분집합
    for j in range(n):
        if i & (1 << j):  # 트루면
            tmp_set.append(lst[j])  # 1인 값 (lst의 j번째) 넣기
    power_set.append(tmp_set)

print(power_set)

#[[], [3], [6], [3, 6], [7], [3, 7], [6, 7], [3, 6, 7], [1], [3, 1], [6, 1], [3, 6, 1], [7, 1], [3, 7, 1], [6, 7, 1], [3, 6, 7, 1]]
```


